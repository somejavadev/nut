#!/bin/sh
# BIG NOTE: Not bash, not any other predetermined shell implementation
#
# NOTE: This script is intentionally written with portable shell constructs
#       with the aim and hope to work in different interpreters, so it is a
#       bit dumber and less efficient than could be achieved with the more
#       featured shells in the spectrum. Also, to minimize the in-memory and
#       debug-console traffics, tests for (non-)emptiness of anticipated large
#       strings are not done by `test -n/-z`, but by counting the size of the
#       string (zero or not).
# NOTE ALSO: The configuration parser in this script is not meant to be a
#       reference or 100% compliant with what the binary code uses; its aim
#       is to just pick out some strings relevant for tracking config changes.
#
# Copyright (C) 2016-2019 Eaton
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#! \file    nut-driver-enumerator.sh(.in)
#  \author  Jim Klimov <EvgenyKlimov@eaton.com>
#  \brief   Enumerate NUT devices for service-unit instance configuration
#  \details This script allows to enumerate UPSes in order to produce the
#           individual service unit instances for each defined configuration.
#           It assumes the user has adequate permissions to inspect and create
#           services (e.g. is a root or has proper RBAC profiles to do so).
#           It helps service frameworks such as Linux systemd and Solaris SMF.
#           When executed, this script looks for all configured ups.conf
#           sections and registered service instances, and makes these two
#           lists match up. It has also a mode to do this in a loop, to keep
#           checking for differences and applying them, on systems where it's
#           problematic to trigger it in response to FS event notifications.
#           Returns exit codes:
#               0   Sections and services already match up
#               42  Sections and services differed, but now match up -
#                   now the caller should likely restart some services.
#                   Note that the drivers' service instances were started or
#                   stopped as required (by AUTO_START=yes) - but maybe the
#                   upsd or upsmon services should restart. If you pass envvar
#                   REPORT_RESTART_42=no then this codepath would return 0.
#                   In default mode, such non-null reconfiguration should cause
#                   the nut-driver-enumerator service to restart and this would
#                   propagate to other NUT services that depend on it.
#               13  Sections and services differed, and still do not match up
#               1   Bad inputs, e.g. unrecognized service management framework
#               2   Absent or unreadable ups.conf file
#

# NOTE: Currently found caveats that might be solved later but require
# considerable effort:
# * Solaris SMF constrains the syntax of valid strings for instance names
#   (e.g. not starting with a digit, no period chars) which blocks creation
#   of some UPS driver instances. This might be worked around by hashing
#   the device name e.g. to base64 (and un-hashing instance name when calling
#   upsdrvctl), but is not quite user-friendly. Also can store device name
#   in a service attribute while mangling the instance name to a valid subset.
#   Comparisons (if devices are already wrapped) becomes more complicated in
#   the script in either case, as well as in the service startup method.
# ** The `+` `/` `=` characters from base64 are also invalid for SMF instance
#    name, but the first two can be sed'ed to `-` `_`  and back, for example.
#    Some prefix word is also needed (avoid starting with a digit).
#    The trailing padding `=` can be dropped, and added until we get a
#    non-empty decode. Conversions can be done by
#    `echo "$string" | openssl base64 -e|-d`
# * Dummy-UPS services that "proxy" another locally defined section are
#   essentially a circular dependency for upsd. While the system might
#   start-up lacking a driver, there should be some timer to re-enable
#   failed not-disabled drivers (would be useful in any case though).

# PERF TODO (2019-04), logging due to planned time off from the improvement PoC:
# Recent commits added new routines to speed up mass-processing use-cases (e.g.
# config-service setup reconciliation) based on upsconf_getAllSections_Hash().
# Currently it is geared towards calculating a map of section names to some
# one (stdin-passed) processing product of the normalized section content.
# This is used in the PoC to separately map it to a base64 form of the content
# useful for faster lookups, or to an MD5 of this content for change detection.
# The "processing routines" like calc_md5_stdin() are suboptimal due to use of
# `cat` to make a string variable (the idea being to not pass large text over
# routine CLI args where possible due to potential sensitivity of data and to
# minimize shell envvar creation and processing) and ultimately the text is
# still converted into envvar for trying into different hashing options that
# may be present on a system (e.g. openssl CLI vs dedicated tools like md5sum).
# * consider a less generic routine for making one table in one pass over the
#   NUT config file of [DEVICE]<TAB>MD5<TAB>BASE64 entries, fix value-getters
#   accordingly
# * detect the hashing solution for md5 and base64 (functional, maybe faster
#   of several available?) upon startup, and only call it allowing for simpler
#   code paths including stdin support without complicated fallbacks seen now
# * simplify code to avoid `cat` and pass config snippets (relatively small)
#   as text envvars easy to forward into several hashers in a row
# * plug these new routines into production code for actual benefit
# * in daemonized loop mode, make sure to re-parse the existing NUT ups.conf
#   file (if it changed) into the cache so changes are detected in fact

# Directory where NUT configs are located, e.g. /etc/nut or /etc/ups
# Set at package configuration, compiled into daemons and drivers
prefix="@prefix@"
[ -n "${NUT_CONFPATH-}" ] || NUT_CONFPATH="@sysconfdir@"
# Technically this should be a distribution-dependent value configured
# during package build. But everyone has it the same from systemd defaults:
[ -n "${SYSTEMD_CONFPATH-}" ] || SYSTEMD_CONFPATH="/etc/systemd/system"

if [ -n "$ZSH_VERSION" ]; then
    ### Problem: loops like `for UPS in $UPSLIST` do not separate
    ### the UPSLIST into many tokens but use it as one string.
    echo "FATAL: zsh is not supported in this script" >&2
    exit 1
#    setopt noglob
#    setopt +F
#    IFS="`printf ' \t\r\n'`" ; export IFS
fi

# Third-party services to depend on (can be overridden by config file)
### Note that for systemd+udev integration, it may be better to set up
### triggers in udev, see e.g.
###   http://stackoverflow.com/questions/18463755/linux-start-daemon-on-connected-usb-serial-dongle
### Also can tune whether a driver "Wants" another service (would consider
### ordering if that one is enabled, but live if it is disabled), or if it
### "Requires" that (would cause that to start).
DEPSVC_USB_SYSTEMD="systemd-udev.service systemd-udev-settle.service"
DEPREQ_USB_SYSTEMD="Wants"
DEPSVC_NET_FULL_SYSTEMD="network-online.target systemd-resolved.service ifplugd.service"
DEPREQ_NET_FULL_SYSTEMD="Wants"
DEPSVC_NET_LOCAL_SYSTEMD="network.target"
DEPREQ_NET_LOCAL_SYSTEMD="Wants"
SVCNAME_SYSTEMD="nut-driver"

# Some or all of these FMRIs may be related to dynamically changing hardware
#   require_all) ;; # All cited services are running (online or degraded)
#   require_any) ;; # At least one of the cited services is running
#   optional_all) ;; # (All) cited services are running or would not run
#                  # without administrative action (disabled, maintenance,
#                  # not present, or are waiting for dependencies which do
#                  # not start without administrative action).
DEPSVC_USB_SMF="svc:/system/hotplug:default svc:/system/dbus:default svc:/system/hal:default svc:/milestone/devices:default"
DEPREQ_USB_SMF="optional_all"
# By default there are several physical network FMRIs shipped and at most
# only one is enabled on a particular system (e.g. :default or :nwam)
DEPSVC_NET_FULL_SMF="svc:/network/physical svc:/milestone/name-services"
DEPREQ_NET_FULL_SMF="optional_all"
DEPSVC_NET_LOCAL_SMF="svc:/network/loopback:default"
DEPREQ_NET_LOCAL_SMF="optional_all"
SVCNAME_SMF="svc:/system/power/nut-driver"

# Config may set this to true
NDE_DEVEL_DEBUG="false"
[ -z "${NUT_DRIVER_ENUMERATOR_CONF-}" ] && \
    NUT_DRIVER_ENUMERATOR_CONF="${NUT_CONFPATH}/nut-driver-enumerator.conf"

[ -s "${NUT_DRIVER_ENUMERATOR_CONF}" ] && \
    echo "Sourcing config file: ${NUT_DRIVER_ENUMERATOR_CONF}" >&2 && \
    . "${NUT_DRIVER_ENUMERATOR_CONF}" >&2

[ -z "${UPSCONF-}" ] && \
    UPSCONF="${NUT_CONFPATH}/ups.conf"

# Start a freshly-registered unit?
[ -z "${AUTO_START-}" ] && AUTO_START=yes

# We avoid regex '\t' which gets misinterpreted by some tools
TABCHAR="`printf '\t'`" || TABCHAR='	'

if [ -z "${SERVICE_FRAMEWORK-}" ] ; then
    [ -x /usr/sbin/svcadm ] && [ -x /usr/sbin/svccfg ] && [ -x /usr/bin/svcs ] && [ -x /usr/bin/svcprop ] && \
        SERVICE_FRAMEWORK="smf"
    [ -z "${SERVICE_FRAMEWORK-}" ] && \
        [ -x /bin/systemctl ] && \
        SERVICE_FRAMEWORK="systemd"
fi

# Optionally use Coreutils timeout to limit the
# (potentially hanging) calls to systemd tools...
# Should not hurt with SMF too, if it ever misbehaves.
if [ -z "${TIMEOUT_CMD+x}" ]; then
    # Envvar not set at all (set but empty is okay, caller wants that then)
    TIMEOUT_CMD=""
    TIMEOUT_ARGS=""
    if which timeout 2>/dev/null >/dev/null ; then
        # Systemd default timeout for unit start/stop
        TIMEOUT_CMD="timeout"
        TIMEOUT_ARGS="90s"
    fi
fi

# Cache needed bits of ups.conf to speed up later parsing. Note that these
# data are needed for most operations, and populated by upslist_readFile()
UPSCONF_DATA=""
# Subset of normalized data above that only has sections, drivers and ports
UPSCONF_DATA_SDP=""

# List of configured UPSes in the config-file
UPSLIST_FILE=""
# List of configured service instances for UPS drivers
UPSLIST_SVCS=""

# Framework-specific implementations are generally hooked here:
hook_registerInstance=""
hook_unregisterInstance=""
hook_refreshSupervizor=""
hook_listInstances=""
hook_listInstances_raw=""
hook_validInstanceName=""
hook_validFullUnitName=""
hook_validInstanceSuffixName=""
hook_getSavedDeviceName=""
hook_findSavedDeviceName=""
hook_setSavedDeviceName=""
hook_getSavedMD5=""
hook_setSavedMD5=""
hook_restart_upsd=""
hook_restart_drv=""

case "${SERVICE_FRAMEWORK-}" in
    smf)
        hook_registerInstance="smf_registerInstance"
        hook_unregisterInstance="smf_unregisterInstance"
        hook_refreshSupervizor="smf_refreshSupervizor"
        hook_listInstances="smf_listInstances"
        hook_listInstances_raw="smf_listInstances_raw"
        hook_validInstanceName="smf_validInstanceName"
        hook_validFullUnitName="smf_validFullUnitName"
        hook_validInstanceSuffixName="smf_validInstanceSuffixName"
        hook_getSavedDeviceName="smf_getSavedDeviceName"
        hook_findSavedDeviceName="smf_findSavedDeviceName"
        hook_setSavedDeviceName="smf_setSavedDeviceName"
        hook_getSavedMD5="smf_getSavedMD5"
        hook_setSavedMD5="smf_setSavedMD5"
        hook_restart_upsd="smf_restart_upsd"
        hook_restart_drv="smf_restart_drv"
        ;;
    systemd)
        hook_registerInstance="systemd_registerInstance"
        hook_unregisterInstance="systemd_unregisterInstance"
        hook_refreshSupervizor="systemd_refreshSupervizor"
        hook_listInstances="systemd_listInstances"
        hook_listInstances_raw="systemd_listInstances_raw"
        hook_validInstanceName="systemd_validInstanceName"
        hook_validFullUnitName="systemd_validFullUnitName"
        hook_validInstanceSuffixName="systemd_validInstanceSuffixName"
        hook_getSavedDeviceName="systemd_getSavedDeviceName"
        hook_findSavedDeviceName="systemd_findSavedDeviceName"
        hook_setSavedDeviceName="systemd_setSavedDeviceName"
        hook_getSavedMD5="systemd_getSavedMD5"
        hook_setSavedMD5="systemd_setSavedMD5"
        hook_restart_upsd="systemd_restart_upsd"
        hook_restart_drv="systemd_restart_drv"
        ;;
    selftest)
        hook_registerInstance="selftest_NOOP"
        hook_unregisterInstance="selftest_NOOP"
        hook_refreshSupervizor="selftest_NOOP"
        hook_listInstances="selftest_NOOP"
        hook_listInstances_raw="selftest_NOOP"
        hook_validInstanceName="selftest_NOOP"
        hook_validFullUnitName="selftest_NOOP"
        hook_validInstanceSuffixName="selftest_NOOP"
        hook_getSavedDeviceName="selftest_NOOP"
        hook_findSavedDeviceName="selftest_NOOP"
        hook_setSavedDeviceName="selftest_NOOP"
        hook_getSavedMD5="selftest_NOOP"
        hook_setSavedMD5="selftest_NOOP"
        hook_restart_upsd="selftest_NOOP"
        hook_restart_drv="selftest_NOOP"
        ;;
    "")
        echo "Error detecting the service-management framework on this OS" >&2
        exit 1
        ;;
    *)
        echo "Error: User provided an unknown service-management framework '$SERVICE_FRAMEWORK'" >&2
        exit 1
        ;;
esac

selftest_NOOP() {
    echo "NO-OP: Self-testing context does not do systems configuration" >&2
    return 0
}

common_isFiled() {
    [ "${#UPSLIST_FILE}" != 0 ] && \
    for UPSF in $UPSLIST_FILE ; do
        [ "$1" = "$UPSF" ] && return 0
        [ "`$hook_validInstanceName "$UPSF"`" = "$1" ] && return 0
    done
    return 1
}

common_isRegistered() {
    [ "${#UPSLIST_SVCS}" != 0 ] && \
    for UPSS in $UPSLIST_SVCS ; do
        [ "$1" = "$UPSS" ] && return 0
        [ "`$hook_validInstanceName "$1"`" = "$UPSS" ] && return 0
    done
    return 1
}

# List of [DEVICE]<TAB>MD5_<hash-of-DEVICE> entries
CACHED_INSTANCE_NAMES=""
cached_validInstanceName() {
    # Return MD5_<hash> of $1 string; empty $1 means global section
    if [ "${#CACHED_INSTANCE_NAMES}" != 0 ]; then
        # Find in cache first, echo the hit if any
        awk -F"${TABCHAR}" 'BEGIN { hit=0; }
( $1 == "['"$1"]'") {print $2; ++hit; exit 0 ; }
END { if (hit == 0 ) { exit 1 } ; }' << EOF
${CACHED_INSTANCE_NAMES}
EOF
        [ $? = 0 ] && return
    fi
    # Calculate, cache and report the value
    _VAL="MD5_`calc_md5 "$1"`" && [ "${#_VAL}" != 0 ] || return 1
    echo "${_VAL}"
    CACHED_INSTANCE_NAMES="$CACHED_INSTANCE_NAMES
[$1]	${_VAL}"
    return 0
}

update_validInstanceNames() {
    # create or update the mappings for MD5 names in the cache
    # use this after e.g. reading in a list of devices from NUT config
    # TODO : preselect DEV's that are not in list (if not empty) yet
    # and make these a uniq'ed list
    CACHED_INSTANCE_NAMES="$CACHED_INSTANCE_NAMES
$(for DEV in "$@" ; do
    egrep "^\[$DEV\]" >/dev/null << EOF && continue
${CACHED_INSTANCE_NAMES}
EOF
    VAL="MD5_`calc_md5 "${DEV}"`" && [ "${#VAL}" != 0 ] || continue
    echo "[${DEV}]	${VAL}"
done)"
}

upslist_equals() {
    # Compare pre-sorted list of DEVICES ($1) and SVCINSTs ($2) including
    # the possible mangling for service names. Return 0 if lists describe
    # exactly same set of devices and their services.
    # Note: This logic only checks the names, not the contents of device
    # sections, so re-definitions of an existing device configuration
    # would not trigger a service restart by itself. Such deeper check
    # belongs in a different routine, see upssvcconf_checksum_unchanged().

    # Trivial case 0: one string is empty, another is not
    # Note: `echo '' | wc -l` == "1" not "0"!
    [ "${#1}" != 0 -a "${#2}" = 0 ] && return 1
    [ "${#1}" = 0 -a "${#2}" != 0 ] && return 1

    # Trivial case 1: equal strings
    [ "$1" = "$2" ] && return 0
    # Trivial case 2: different amount of entries
    [ "`echo "$1" | wc -l`" = "`echo "$2" | wc -l`" ] || return $?

    # Make a list of services that correspond in two lists
    _TMP_DEV_SVC="$( for _DEV in $1 ; do
        DEVINST="`$hook_validInstanceName "${_DEV}"`"
        for _SVC in $2 ; do
            [ "${_DEV}" = "${_SVC}" ] \
            || [ "$DEVINST" = "${_SVC}" ] \
            && echo "${_DEV} = ${_SVC}" \
            && break
        done
    done )"

    # Input was not empty; did anything in output fit?
    [ "${#_TMP_DEV_SVC}" = 0 ] && return 1

    # Exit code : is the built mapping as long as the source list(s)?
    [ "`echo "$1" | wc -l`" = "`echo "${_TMP_DEV_SVC}" | wc -l`" ]
}

upssvcconf_checksum_unchanged() {
    # $1 = dev, $2 = svc
    # compare checksums of the configuration section from the file and the
    # stashed configuration in a service instance (if any).
    # Empty values mean checking the global section.
    # FIXME : optimize by caching, we likely have quite a few requests
    [ "`upsconf_getSection_MD5 "$1"`" = "`$hook_getSavedMD5 "$2"`" ]
}

upslist_checksums_file() {
    # List a table of [DEVNAME]<TAB>CHECKSUM for devices listed in $*
    # arguments, using the data from NUT configuration
    upsconf_getAllSections_MD5_once # gives UPSCONF_HASH_MD5
    # Note: intentionally not "$@" here:
    for _DEV in $* ; do
        printf '[%s]\t%s\n' "${_DEV}" "`upsconf_getSection_MD5 "${_DEV}"`"
    done
}

upslist_checksums_file_once() {
    # List a table of [DEVNAME]<TAB>CHECKSUM for devices listed in $*
    # arguments, using data from NUT configuration
    # PERF : Separate a use-case for known full list to return it ASAP?
    upsconf_getAllSections_MD5_once # gives UPSCONF_HASH_MD5
    # Note: intentionally not "$@" here:
    for _DEV in $* ; do
        egrep "^\[${_DEV}\]${TABCHAR}" << EOF
${UPSCONF_HASH_MD5}
EOF
    done
}

upslist_checksums_saved() {
    # List a table of DEVNAME<TAB>CHECKSUM for devices listed in $*
    # arguments, using saved service instance properties
    # Note: intentionally not "$@" here:
    for _DEV in $* ; do
        printf '[%s]\t%s\n' "${_DEV}" "`$hook_getSavedMD5 "${_DEV}"`"
    done
}

upslist_checksums_unchanged() {
    # For each device and its corresponding unit, compare checksums of the
    # configuration section from the file and the stashed configuration in
    # a service instance. Prints a list of mismatching service names that
    # should get reconfigured.
    [ "${#1}" = 0 -o "${#2}" = 0 ] && return 1

    # Better have them all than pick bits, in this routine
#    CFGSUMS_FILE="`upslist_checksums_file "$1"`"
#    CFGSUMS_FILE="`upslist_checksums_file_once "$1"`"
    upsconf_getAllSections_MD5_once
    CFGSUMS_FILE="${UPSCONF_HASH_MD5}"
    CFGSUMS_SAVE="`upslist_checksums_saved "$2"`"

    _RES=0
    for _DEV in $1 ; do
        for _SVC in $2 ; do
            if [ "${_DEV}" = "${_SVC}" ] \
            || [ "`$hook_validInstanceName "${_DEV}"`" = "${_SVC}" ] \
            ; then
                CFGSUM_FILE="`echo "$CFGSUMS_FILE" | egrep "^\[${_DEV}\]${TABCHAR}"`"
                CFGSUM_SAVE="`echo "$CFGSUMS_SAVE" | egrep "^\[${_DEV}\]${TABCHAR}"`"
                [ "${#CFGSUM_FILE}" != 0 ] \
                && [ "${CFGSUM_FILE}" = "${CFGSUM_SAVE}" ] \
                && break \
                || { echo "${_SVC}" ; _RES=1; }
            fi
        done
    done
    return ${_RES}
}

upslist_savednames_find_missing() {
    # Verify that all existing service units have some saved DEVICE name;
    # this routine does not check if that saved value makes any sense.
    # Report those instances that do not have any value there so we can
    # amend them quickly after an upgrade. Otherwise we trust these to
    # have been generated properly and not mangled by users or storage.
    # Note the mismatch can also happen for systemd if a service is not
    # "enabled", so when just its files exist.
    # See upslist_savednames_find_mismatch() below for more pedantic check.

    # Get full instance names from system
    SVCINSTS="`$hook_listInstances_raw | sort`" && [ "${#SVCINSTS}" != 0 ] || return 1
    # Get a mapping of full instance names to device names
    # (for those service instances that do have them saved)
    SVCINSTS_PROPS="`$hook_findSavedDeviceName`" && [ "${#SVCINSTS_PROPS}" != 0 ] \
    || { # If no props were found, (over)write them all
        echo $SVCINSTS ; return 2; }

    # Find services in system which do not have saved names in props:
    # entry missing altogether, or entry with empty device-name column.

    # First pick just the service names that do have the device column
    SVCINSTS_PROPS_COMPLETE="`awk -F"${TABCHAR}" '($2 != ""){print $1}' << EOF | sort
$SVCINSTS_PROPS
EOF`"
    if [ "${SVCINSTS}" = "${SVCINSTS_PROPS_COMPLETE}" ] ; then
        # All services are already well configured
        return 0
    fi

    # Now find the difference of all the system instances vs those that
    # have the props set
    for SVCINST in $SVCINSTS ; do
        echo "$SVCINSTS_PROPS_COMPLETE" | grep -x "${SVCINST}" >/dev/null || echo "$SVCINST"
    done
}

upslist_savednames_find_mismatch() {
    # TODO: Make use of this to fsck the enumerator configs
    #
    # Verify that all existing service units have a saved DEVICE name
    # and that such name does match the unit instance's name (original
    # or MD5 normalized version). If something does not match, returns
    # the unit name so it can be redefined by caller. This does not
    # inspect whether such DEVICE is defined in NUT configuration.
    # This situation might occur in some errors, but the likely case
    # is updating from versions that did not track this info yet (but
    # upslist_savednames_find_missing() should have handled those).

    # Get full instance names from system
    SVCINSTS="`$hook_listInstances_raw | sort`" && [ "${#SVCINSTS}" != 0 ] || return 1

    # If there is no NUT config (or got an error reading it), tell the
    # caller to reconfigure everything
    upslist_readFile_once && [ "${#UPSLIST_FILE}" != 0 ] \
        || { echo "No devices detected in '$UPSCONF'" >&2 ; echo "$SVCINSTS"; return 0 ; }

    # Get a mapping of full instance names to device names
    # (for those service instances that do have them saved)
    SVCINSTS_PROPS="`$hook_findSavedDeviceName`" && [ "${#SVCINSTS_PROPS}" != 0 ] || return 2

    # Perform consistency checks for service instances which already
    # have the DEVICE property
    echo "$SVCINSTS_PROPS" | while read SVCINST_PROP DEVNAME_PROP ; do
        [ -n "${DEVNAME_PROP}" ] || { echo "$SVCINST_PROP" ; continue ; }

        # Find services whose props exist but services do not (may be a
        # file data-staleness problem with systemd, but not likely with
        # SMF as it is all in one database):
        grep -x "${SVCINST_PROP}" >/dev/null << EOF || { echo "$SVCINST_PROP" ; continue ; }
$SVCINSTS
EOF

        # Verify the DEVNAME_PROP against SVCINST_PROP (check that
        # the name is verbatim or MD5 match):
        vUNITD="`$hook_validFullUnitName "$DEVNAME_PROP"`"
        if [ "${vUNITD}" != "${SVCINST_PROP}" ] ; then
            vINST="`$hook_validInstanceName "$DEVNAME_PROP"`"
            vUNITI="`$hook_validFullUnitName "$vINST"`"
            [ "${vUNITI}" = "${SVCINST_PROP}" ] || { echo "$SVCINST_PROP" ; continue ; }
        fi

        # Verify that DEVNAME_PROP exists in UPSLIST_FILE:
        grep -x "${DEVNAME_PROP}" >/dev/null << EOF || { echo "$SVCINST_PROP" ; continue ; }
$UPSLIST_FILE
EOF
    done

    # Find services which do not have saved names in props, so they
    # should be remade by caller
    # First, pick just the service names that do have the device column
    SVCINSTS_PROPS_COMPLETE="`awk -F"${TABCHAR}" '($2 != ""){print $1}' << EOF | sort
$SVCINSTS_PROPS
EOF`"
    # Now find the difference of all the system instances vs those that
    # have the props set
    for SVCINST in $SVCINSTS ; do
        grep -x "${SVCINST}" >/dev/null << EOF || echo "$SVCINST"
$SVCINSTS_PROPS_COMPLETE
EOF
    done

    # Note: we do not check here for services whose names do not match
    # any device or vice versa, this is the main loop's job
}

upsconf_getSection_content() {
    # "$1" = name of ups.conf section to display in whole, from whatever
    # comes on stdin (file or a pre-made normalized variable)
    # empty "$1" means the global config (before any sections)
    #
    # PERF: This routine finds the one NUT device section, prints it and
    # returns when the section is over. It currently does not cover (in
    # a way allowing to do it efficiently) selection of several sections,
    # or storing each section content in some array or dynamic variables
    # (as would be better fit for portable shells) to later address them
    # quickly without re-parsing the file or big envvar many times.
    #

    CURR_SECTION=""
    SECTION_CONTENT=""
    # If a (non-global) section is requested, by default we failed to find it:
    [ "${#1}" = 0 ] && RES=0 || RES=1
    while read LINE ; do
        case "$LINE" in
            \["$1"\])
                if [ "$RES" = 0 ]; then
                    # We have already displayed a section, here is a new one,
                    # and this routine only displays one (TODO: toggle?)
                    break
                fi
                SECTION_CONTENT="$LINE"
                CURR_SECTION="$1"
                RES=0
                continue
                ;;
            \[*\ *\]|\[*"$TABCHAR"*\])
                # Note that section-name brackets should contain a single token
                # Fall through to add the line to contents of existing section
                ;;
            \[*\])
                # We have just displayed the requested section,
                # and here starts a new one -- so we are done.
                # Empty $1 also fits (global config section).
                [ "$CURR_SECTION" = "$1" ] && break
                # Use a value that can not be a section name here
                # just to "ignore" this section content in our loop:
                CURR_SECTION="[]"
                continue
                ;;
            "") continue ;;
            *)  ;; # Fall through to add the line to contents of existing section
        esac
        if [ "$CURR_SECTION" = "$1" ]; then
            if [ "${#SECTION_CONTENT}" = 0 ]; then
                SECTION_CONTENT="$LINE"
            else
                SECTION_CONTENT="$SECTION_CONTENT
$LINE"
            fi
        fi
    done

    if [ -n "$SECTION_CONTENT" ]; then
        echo "$SECTION_CONTENT"
    fi

    [ "$RES" = 0 ] || echo "ERROR: Section [$1] was not found in the '$UPSCONF' file" >&2
    return $RES
}

upsconf_getSection() {
    # Use the whole output of normalization parser
    upslist_normalizeFile_once || return    # Propagate errors upwards
    upsconf_getSection_content "$@" << EOF
${UPSCONF_DATA}
EOF
}

upsconf_getSection_MD5() {
    calc_md5 "`upsconf_getSection "$@"`"
}

upsconf_getAllSections_MD5() {
    # Parse the whole config in one take, producing a list
    # of all [DEVICE]<TAB>CHECKSUM lines
    upsconf_getAllSections_Hash calc_md5_stdin
}

UPSCONF_HASH_MD5=""
upsconf_getAllSections_MD5_once() {
    # Needed output is in UPSCONF_HASH_MD5
    UPSCONF_HASH_RES=0
    [ "${#UPSCONF_HASH_MD5}" = 0 ] || { return 0 ; }
    upslist_normalizeFile_once || return    # Propagate errors upwards
    UPSCONF_HASH_MD5="`upsconf_getAllSections_MD5`" || { UPSCONF_HASH_RES=$? ; UPSCONF_HASH_MD5="" ; }
    return $UPSCONF_HASH_RES
}

upsconf_getSection_MD5_once() {
    # Return checksum for device section "$1"
    # WARNING: This is intended for mass-usage scenario, so it pre-reads
    # and pre-calculates the whole config file's worth of section checksums
    upsconf_getAllSections_MD5_once || return # gives UPSCONF_HASH_MD5
    egrep "^\[${1}\]" << EOF | awk -F"${TABCHAR}" '{print $NF}'
${UPSCONF_HASH_MD5}
EOF
}

upsconf_getSection_content_once() {
    # Return content for device section "$1"
    # WARNING: This is intended for mass-usage scenario, so it pre-reads
    # and pre-calculates the whole config file's worth of section base64
    # encodings to grep them quickly and decode afterwards
    upsconf_getAllSections_BASE64_once || return # gives UPSCONF_HASH_BASE64
    egrep "^\[${1}\]" << EOF | awk -F"${TABCHAR}" '{print $NF}' | calc_debase64_stdin
${UPSCONF_HASH_BASE64}
EOF
}

upsconf_getAllSections_BASE64() {
    # Parse the whole config in one take, producing a list
    # of all [DEVICE]<TAB>BASE64 lines
    upsconf_getAllSections_Hash calc_base64_stdin
}

UPSCONF_HASH_BASE64=""
upsconf_getAllSections_BASE64_once() {
    # Needed output is in UPSCONF_HASH_BASE64
    UPSCONF_HASH_RES=0
    [ "${#UPSCONF_HASH_BASE64}" = 0 ] || { return 0 ; }
    upslist_normalizeFile_once || return    # Propagate errors upwards
    UPSCONF_HASH_BASE64="`upsconf_getAllSections_BASE64`" || { UPSCONF_HASH_RES=$? ; UPSCONF_HASH_BASE64="" ; }
    return $UPSCONF_HASH_RES
}

upsconf_getAllSections_Hash() {
    # Parse the normalized config once, producing a list of all
    # [DEVICE]<TAB>SOME_HASH lines, with the hash function defined
    # by "$@" arguments, taking on stdin the contents of a section
    # (including its [devicename] as a start - for non-globals)
    [ "$#" != 0 ] || return
    upslist_normalizeFile_once || return    # Propagate errors upwards

    CURR_SECTION=""
    SECTION_CONTENT=""
    while read LINE ; do
        case "$LINE" in
            \[*\ *\]|\[*"$TABCHAR"*\])
                # Note that section-name brackets should contain a single token
                # Fall through to add the line to contents of existing section
                ;;
            \[*\])
                if [ "${#SECTION_CONTENT}" != 0 ]; then
                    # We have some content, report it, using the hashfunc from args
                    # Note that CURR_SECTION is surrounded by brackets
                    [ "${#CURR_SECTION}" = 0 ] && CURR_SECTION="[]" # global cfg
                    printf '%s\t%s\n' "$CURR_SECTION" "`"$@" << EOF
$SECTION_CONTENT
EOF`"
                fi
                SECTION_CONTENT="$LINE"
                ### Cut off brackets?
                ###CURR_SECTION="`echo "$LINE" | sed 's,^.*\[\([^]]*\)\].*,\1,'`"
                ### Cut off trash around brackets, if any
                CURR_SECTION="`echo "$LINE" | sed 's,^.*\(\[[^]]*\]\).*\$,\1,'`"
                continue
                ;;
            "") continue ;;
            *)  ;; # Fall through to add the line to contents of existing section
        esac
        if [ "${#SECTION_CONTENT}" = 0 ]; then
            SECTION_CONTENT="$LINE"
        else
            SECTION_CONTENT="$SECTION_CONTENT
$LINE"
        fi
    done << EOF
${UPSCONF_DATA}
EOF
}

upsconf_getSection_SDP() {
    # Use the section-driver-port subset
    upslist_normalizeFile_once || return    # Propagate errors upwards
    upsconf_getSection_content "$@" << EOF
${UPSCONF_DATA_SDP}
EOF
}

upsconf_getValue() {
    # "$1" = name of ups.conf section, may be empty for global config
    # "$2..$N" = name of config key; we will echo its value
###    [ -n "$1" ] || return $?
    [ -n "$2" ] || return $?
    [ -n "$GETSECTION" ] || GETSECTION="upsconf_getSection"
    CURR_SECTION="" # Gets set by a GETSECTION implementation
    RES=0

    # Note: Primary aim of this egrep is to pick either assignments or flags
    # As a by-product it can be used to test if a particular value is set ;)
    SECTION_CONTENT="`$GETSECTION "$1"`" || return
    shift
    KEYS="$*"

    while [ "$#" -gt 0 ] ; do
        RES_L=0
        VALUE=""

        LINE="`echo "$SECTION_CONTENT" | egrep '(^'"$1"'=|^'"$1"'$)'`" \
        && VALUE="$(echo "$LINE" | sed -e "s,^$1=,," -e 's,^\"\(.*\)\"$,\1,' -e "s,^'\(.*\)'\$,\1,")" \
        || RES_L=$?

        [ "$RES_L" = 0 ] || { RES="$RES_L" ; echo "ERROR: Section [$CURR_SECTION] or key '$1' in it was not found in the '$UPSCONF' file" >&2 ; }

        echo "$VALUE"
        shift
    done

    [ "$RES" = 0 ] || echo "ERROR: Section [$CURR_SECTION] or key(s) '$KEYS' in it was not found in the '$UPSCONF' file" >&2
    return $RES
}

upsconf_getDriver() {
    # "$1" = name of ups.conf section; return (echo) the driver name used there
    # In the context this function is used, UPSCONF exists and section is there
    GETSECTION="upsconf_getSection_SDP" upsconf_getValue "$1" "driver"
    return $?
}

upsconf_getPort() {
    # "$1" = name of ups.conf section; return (echo) the "port" name used there
    # In the context this function is used, UPSCONF exists and section is there
    GETSECTION="upsconf_getSection_SDP" upsconf_getValue "$1" "port"
    return $?
}

upsconf_getDriverMedia() {
    # "$1" = name of ups.conf section; return (echo) name and type of driver as
    # needed for dependency evaluation (what services we must depend on for this
    # unit), newline-separated (drvname<EOL>type). Empty type for unclassified
    # results, assuming no known special dependencies (note that depending on
    # particular system's physics, both serial and network media may need USB).
    CURR_DRV="`upsconf_getDriver "$1"`" || return $?
    case "$CURR_DRV" in
        *netxml*|*snmp*|*ipmi*|*powerman*|*-mib*|*avahi*|*apcupsd*)
            printf '%s\n%s\n' "$CURR_DRV" "network" ; return ;;
        *usb*)
            printf '%s\n%s\n' "$CURR_DRV" "usb" ; return ;;
        nutdrv_qx) # May be direct serial or USB
            CURR_PORT="`upsconf_getPort "$1"`" || CURR_PORT=""
            case "$CURR_PORT" in
                auto|/dev/*usb*|/dev/*hid*)
                    printf '%s\n%s\n' "$CURR_DRV" "usb" ; return ;;
                /dev/*)
                    # See drivers/nutdrv_qx.c :: upsdrv_initups() for a list
                    if [ -n "`upsconf_getValue "$1" 'subdriver' 'vendorid' 'productid' 'vendor' 'product' 'serial' 'bus' 'langid_fix'`" ] \
                    ; then
                        printf '%s\n%s\n' "$CURR_DRV" "usb" ; return
                    else
                        printf '%s\n%s\n' "$CURR_DRV" "serial" ; return
                    fi
                    ;;
                *)
                    printf '%s\n%s\n' "$CURR_DRV" "" ; return ;;
            esac
            ;;
        *dummy*|*clone*) # May be networked (proxy to remote NUT)
            CURR_PORT="`upsconf_getPort "$1"`" || CURR_PORT=""
            case "$CURR_PORT" in
                *@localhost|*@|*@127.0.0.1|*@::1)
                    printf '%s\n%s\n' "$CURR_DRV" "network-localhost" ; return ;;
                *@*)
                    printf '%s\n%s\n' "$CURR_DRV" "network" ; return ;;
                *)
                    printf '%s\n%s\n' "$CURR_DRV" "" ; return ;;
            esac
            ;;
        *)  printf '%s\n%s\n' "$CURR_DRV" "" ; return ;;
    esac
}

upsconf_getMedia() {
    _DRVMED="`upsconf_getDriverMedia "$1"`" || return
    echo "${_DRVMED}" | tail -n +2
    return 0
}

upsconf_debug() {
    _DRV="`upsconf_getDriver "$1"`"
    _PRT="`upsconf_getPort "$1"`"
    _MED="`upsconf_getMedia "$1"`"
    _MD5="`upsconf_getSection_MD5 "$1"`"
    NAME_MD5="`calc_md5 "$1"`"
    echo "INST: ${NAME_MD5}~[$1]: DRV='${_DRV}' PORT='${_PRT}' MEDIA='${_MED}' SECTIONMD5='${_MD5}'"
}

# PERF : check first which tools exist (md5sum, base64, openssl...),
# and then set up calling an existing one directly, especially for
# *_stdin() routines below
calc_md5() {
    # Tries several ways to produce an MD5 of the "$1" argument
    _MD5="`md5sum 2>/dev/null << EOF | awk '{print $1}'
$1
EOF`" && [ "${#_MD5}" != 0 ] || \
    { _MD5="`openssl dgst -md5 2>/dev/null << EOF | awk '{print $NF}'
$1
EOF`" && [ "${#_MD5}" != 0 ]; } || \
    return 1

    echo "${_MD5}"
}

calc_md5_stdin() {
    # Tries several ways to produce an MD5 of the stdin input
    calc_md5 "`cat`"
}

calc_md5_file() {
    # Tries several ways to produce an MD5 of the file named by "$1" argument
    [ -s "$1" ] || return 2

    _MD5="`md5sum 2>/dev/null < "$1" | awk '{print $1}'`" && [ -n "${_MD5}" ] || \
    { _MD5="`openssl dgst -md5 2>/dev/null < "$1" | awk '{print $NF}'`" && [ -n "${_MD5}" ]; } || \
    return 1

    echo "${_MD5}"
}

calc_base64() {
    _B64="`base64 2>/dev/null << EOF
$1
EOF`" && [ "${#_B64}" != 0 ] || \
    { _B64="`openssl enc -base64 -e 2>/dev/null << EOF
$1
EOF`" && [ "${#_B64}" != 0 ]; } || \
    return 1

    echo "${_B64}"
}

calc_base64_stdin() {
    # Tries several ways to produce a BASE64 of the stdin input
    calc_base64 "`cat`"
}

calc_debase64() {
    [ "${#1}" = 0 ] && return 0

    _OUT="`base64 -d 2>/dev/null << EOF
$1
EOF`" && [ "${#_OUT}" != 0 ] || \
    { _OUT="`openssl enc -base64 -d 2>/dev/null << EOF
$1
EOF`" && [ "${#_OUT}" != 0 ]; } || \
    return 1

    echo "${_OUT}"
}

calc_debase64_stdin() {
    # Tries several ways to produce a cleartext from BASE64 of the stdin input
    calc_debase64 "`cat`"
}

smf_validFullUnitName() {
    case "$1" in
        *:*) echo "$1" ;;
        *)   echo "$SVCNAME_SMF:$1" ;;
    esac
}
smf_validInstanceName() {
    cached_validInstanceName "$1"
#    echo "MD5_`calc_md5 "$1"`"
}
smf_validInstanceSuffixName() {
    case "$1" in
        *:*) echo "$1" | sed 's,^.*:\([^:]*\)$,\1,' ;;
        *)   echo "$1" ;;
    esac
}
smf_registerInstance() {
    DEVICE="$1"
    SVCINST="$1"
    if /usr/bin/svcs "nut-driver:$SVCINST" >/dev/null 2>&1 ; then
        smf_unregisterInstance "$SVCINST"
    fi
    /usr/sbin/svccfg -s nut-driver add "$DEVICE" || \
    { SVCINST="`smf_validInstanceName "$1"`" || return
      if /usr/bin/svcs "nut-driver:$SVCINST" >/dev/null 2>&1 ; then
        smf_unregisterInstance "$SVCINST"
      fi
      /usr/sbin/svccfg -s nut-driver add "$SVCINST" || return ; }
    echo "Added instance: 'nut-driver:$SVCINST' for NUT configuration section '$DEVICE'" >&2

    DEPSVC=""
    DEPREQ=""
    _MED="`upsconf_getMedia "$DEVICE"`"
    case "${_MED}" in
        usb)
            DEPSVC="$DEPSVC_USB_SMF"
            DEPREQ="$DEPREQ_USB_SMF" ;;
        network-localhost)
            DEPSVC="$DEPSVC_NET_LOCAL_SMF"
            DEPREQ="$DEPREQ_NET_LOCAL_SMF" ;;
        network)
            DEPSVC="$DEPSVC_NET_FULL_SMF"
            DEPREQ="$DEPREQ_NET_FULL_SMF" ;;
        serial) ;;
        '') ;;
        *)  echo "WARNING: Unexpected NUT media type ignored: '${_MED}'" >&2 ;;
    esac

    TARGET_FMRI="nut-driver:$SVCINST"
    if [ -n "$DEPSVC" ]; then
        [ -n "$DEPREQ" ] || DEPREQ="optional_all"
        echo "Adding '$DEPREQ' dependency for '$SVCINST' on '$DEPSVC'..."

        DEPPG="nut-driver-enumerator-generated"
        RESTARTON="refresh"
        /usr/sbin/svccfg -s "$TARGET_FMRI" addpg "$DEPPG" dependency && \
        /usr/sbin/svccfg -s "$TARGET_FMRI" setprop "$DEPPG"/grouping = astring: "$DEPREQ" && \
        /usr/sbin/svccfg -s "$TARGET_FMRI" setprop "$DEPPG"/restart_on = astring: "$RESTARTON" && \
        /usr/sbin/svccfg -s "$TARGET_FMRI" setprop "$DEPPG"/type = astring: service && \
        /usr/sbin/svccfg -s "$TARGET_FMRI" setprop "$DEPPG"/entities = fmri: "($DEPSVC)" && \
        echo "OK" || echo "FAILED to define the dependency" >&2
    fi

    smf_setSavedMD5 "$SVCINST" "`upsconf_getSection_MD5 "$DEVICE"`"
    # Save original device (config section) name to speed up some searches
    smf_setSavedDeviceName "$SVCINST" "$DEVICE"

    /usr/sbin/svcadm refresh "${TARGET_FMRI}" || return
    if [ "$AUTO_START" = yes ] ; then
        /usr/sbin/svcadm clear "${TARGET_FMRI}" 2>/dev/null || true
        /usr/sbin/svcadm enable "${TARGET_FMRI}" || return
        echo "Started instance: 'nut-driver:$SVCINST' for NUT configuration section '$DEVICE'" >&2
    fi
}
smf_unregisterInstance() {
    echo "Removing instance: 'nut-driver:$1' ..." >&2
    /usr/sbin/svcadm disable -ts 'nut-driver:'"$1" || false
    /usr/sbin/svccfg -s nut-driver delete "$1"
}
smf_refreshSupervizor() {
    :
}
smf_listInstances_raw() {
    # Newer versions have pattern matching; older SMF might not have this luxury
    /usr/bin/svcs -a -H -o fmri | egrep '/nut-driver:'
}
smf_listInstances() {
    # Chop twice, in case there is a leading "svc:/...."
    smf_listInstances_raw | sed -e 's/^.*://' -e 's/^.*://' | sort -n
}
smf_getSavedMD5() {
    # Query service instance $1
    PG="nut-driver-enumerator-generated-checksum"
    PROP="SECTION_CHECKSUM"

    if [ -n "$1" ]; then
        TARGET_FMRI="nut-driver:$1"
    else
        # Global section
        TARGET_FMRI="nut-driver"
        PROP="SECTION_CHECKSUM_GLOBAL"
    fi

    # Note: lookups for GLOBAL cause each service instance to show up
    /usr/bin/svcprop -p "$PG/$PROP" "$TARGET_FMRI" 2>/dev/null | head -1 | awk '{print $NF}'
}
smf_findSavedDeviceName() {
    # Returns long service FMRI which has DEVICE=="$1"
    # For empty "$1" returns a list of all recorded "FMRI<TAB>DEVICE"
    if [ -z "$1" ]; then
        /usr/bin/svcprop -p "nut-driver-enumerator-generated-devicename/DEVICE" \
            'svc:/system/power/nut-driver:*' 2>/dev/null \
            | sed 's|^\(svc:/[^:]*:[^/:]*\)/:properties/nut-driver-enumerator-generated-devicename/DEVICE astring \(.*\)$|\1\t\2|'
    else
        /usr/bin/svcprop -p "nut-driver-enumerator-generated-devicename/DEVICE" \
            "svc:/system/power/nut-driver:$1" 2>/dev/null \
            | sed 's|^\(svc:/[^:]*:[^/:]*\)/:prop.*$|\1|'
    fi
}
smf_getSavedDeviceName() {
    # Query service instance $1
    PG="nut-driver-enumerator-generated-devicename"
    PROP="DEVICE"

    if [ -n "$1" ]; then
        TARGET_FMRI="nut-driver:$1"
    else
        # Global section
        echo ""
        return 0
    fi

    # Note: lookups for GLOBAL cause each service instance to show up
    /usr/bin/svcprop -p "$PG/$PROP" "$TARGET_FMRI" 2>/dev/null | head -1 | awk '{print $NF}'
}
smf_setSavedUniq() {
    # Save data value $5 of type $4 into service FMRI $1
    # under (scrapped and) newly created property group $2
    # and property name $3
    __TARGET_FMRI="$1"
    __PG="$2"
    __PROP="$3"
    __TYPE="$4"
    case "${__TYPE}" in
        *:) ;;
        *) __TYPE="${__TYPE}:" ;;
    esac
    __VAL="$5"
    /usr/sbin/svccfg -s "${__TARGET_FMRI}" delprop "${__PG}" 2>/dev/null || true
    /usr/sbin/svccfg -s "${__TARGET_FMRI}" addpg "${__PG}" application && \
    /usr/sbin/svccfg -s "${__TARGET_FMRI}" setprop "${__PG}/${__PROP}" = "${__TYPE}" "${__VAL}"
    [ $? = 0 ] && echo "OK" || { echo "FAILED to stash the service property ${__PG}/${__PROP}">&2 ; return 1 ; }

    case "${__TARGET_FMRI}" in
        svc:/*:*) ;; # A service instance by full FMRI, refresh
        svc:/*/nut-driver|nut-driver) return 0 ;; # A base non-instance service item for nut-driver (known multi-instance only)
        svc:/*) ;; # A base non-instance service item (not nut-driver)
        *:*) ;; # A service instance by short FMRI, refresh
        *) ;; # A base non-instance service item (not nut-driver)
    esac
    /usr/sbin/svcadm refresh "${__TARGET_FMRI}" || return
}
smf_setSavedMD5() {
    # Save checksum value $2 into service instance $1
    _PG="nut-driver-enumerator-generated-checksum"
    _PROP="SECTION_CHECKSUM"

    if [ -n "$1" ]; then
        _TARGET_FMRI="nut-driver:$1"
    else
        # Global section
        _TARGET_FMRI="nut-driver"
        _PROP="SECTION_CHECKSUM_GLOBAL"
    fi
    smf_setSavedUniq "${_TARGET_FMRI}" "${_PG}" "${_PROP}" astring "$2"
}
smf_setSavedDeviceName() {
    [ -n "$1" ] || return # No-op for global section
    smf_setSavedUniq "nut-driver:$1" "nut-driver-enumerator-generated-devicename" "DEVICE" astring "$2"
}
smf_restart_upsd() {
    echo "Restarting NUT data server to make sure it knows new configuration..."
    /usr/sbin/svcadm enable "nut-server" 2>/dev/null
    /usr/sbin/svcadm clear "nut-server" 2>/dev/null
    /usr/sbin/svcadm refresh "nut-server" || \
    /usr/sbin/svcadm restart "nut-server"
}
smf_restart_drv() {
    echo "Restarting NUT driver instance '$1' to make sure it knows new configuration..."
    /usr/sbin/svcadm enable "nut-driver:$1" 2>/dev/null
    /usr/sbin/svcadm clear "nut-driver:$1" 2>/dev/null
    /usr/sbin/svcadm refresh "nut-driver:$1" || \
    /usr/sbin/svcadm restart "nut-driver:$1"
}

systemd_validFullUnitName() {
    case "$1" in
        *@*.*) echo "$1" ;;
        *@*) echo "$1.service" ;;
        *)   echo "$SVCNAME_SYSTEMD@$1.service" ;;
    esac
}
systemd_validInstanceName() {
    cached_validInstanceName "$1"
#    echo "MD5_`calc_md5 "$1"`"
}
systemd_validInstanceSuffixName() {
    echo "$1" | sed -e 's,^.*@,,' -e 's,\.service$,,'
}
systemd_registerInstance() {
    # Instance is registered by device section name; ultimate name in systemd may differ
    DEVICE="$1"
    SVCINST="$1"
    /bin/systemctl enable 'nut-driver@'"$DEVICE".service || \
    { SVCINST="`systemd_validInstanceName "$1"`" && \
      /bin/systemctl enable 'nut-driver@'"$SVCINST".service || return ; }
    echo "Enabled instance: 'nut-driver@$SVCINST' for NUT configuration section '$DEVICE'" >&2

    DEPSVC=""
    DEPREQ=""
    _MED="`upsconf_getMedia "$DEVICE"`"
    case "${_MED}" in
        usb)
            DEPSVC="$DEPSVC_USB_SYSTEMD"
            DEPREQ="$DEPREQ_USB_SYSTEMD" ;;
        network-localhost)
            DEPSVC="$DEPSVC_NET_LOCAL_SYSTEMD"
            DEPREQ="$DEPREQ_NET_LOCAL_SYSTEMD" ;;
        network)
            DEPSVC="$DEPSVC_NET_FULL_SYSTEMD"
            DEPREQ="$DEPREQ_NET_FULL_SYSTEMD" ;;
        serial) ;;
        '') ;;
        *)  echo "WARNING: Unexpected NUT media type ignored: '${_MED}'" >&2 ;;
    esac
    if [ -n "$DEPSVC" ]; then
        [ -n "$DEPREQ" ] || DEPREQ="#Wants"
        echo "Adding '$DEPREQ'+After dependency for '$SVCINST' on '$DEPSVC'..."
        mkdir -p "${SYSTEMD_CONFPATH}/nut-driver@$SVCINST.service.d" && \
        cat > "${SYSTEMD_CONFPATH}/nut-driver@$SVCINST.service.d/nut-driver-enumerator-generated.conf" <<EOF
# Customization generated `date -u` by nut-driver-enumerator for NUT device '$DEVICE'
# DO NOT EDIT: This file would be removed or overwritten by that service
[Unit]
Description=Network UPS Tools - device driver for NUT device '$DEVICE'
${DEPREQ}=${DEPSVC}
After=${DEPSVC}
EOF
        [ $? = 0 ] && echo "OK" || echo "FAILED to define the dependency" >&2
    fi

    systemd_setSavedMD5 "$SVCINST" "`upsconf_getSection_MD5 "$DEVICE"`"
    systemd_setSavedDeviceName "$SVCINST" "$DEVICE"

    if [ "$AUTO_START" = yes ] ; then
        $TIMEOUT_CMD $TIMEOUT_ARGS /bin/systemctl start --no-block 'nut-driver@'"$SVCINST".service || return
        echo "Started instance: 'nut-driver@$SVCINST' for NUT configuration section '$DEVICE'" >&2
    fi
}
systemd_unregisterInstance() {
    echo "Removing instance: 'nut-driver@$1' ..." >&2
    $TIMEOUT_CMD $TIMEOUT_ARGS /bin/systemctl stop 'nut-driver@'"$1".service || \
    $TIMEOUT_CMD $TIMEOUT_ARGS /bin/systemctl stop 'nut-driver@'"$1".service || \
    $TIMEOUT_CMD $TIMEOUT_ARGS /bin/systemctl stop 'nut-driver@'"$1".service || false

    /bin/systemctl disable 'nut-driver@'"$1".service
    rm -rf "${SYSTEMD_CONFPATH}/nut-driver@$1.service.d"
    /bin/systemctl reset-failed 'nut-driver@'"$1".service
}
systemd_refreshSupervizor() {
    /bin/systemctl daemon-reload
}
systemd_listInstances_raw() {
    /bin/systemctl show 'nut-driver@*' -p Id | egrep '=nut-driver' | sed 's,^Id=,,'
}
systemd_listInstances() {
    systemd_listInstances_raw | sed -e 's/^.*@//' -e 's/\.service$//' | sort -n
}
systemd_getSavedMD5() {
    # Query service instance $1 or global section
    PROP="SECTION_CHECKSUM"
    [ -n "$1" ] || PROP="SECTION_CHECKSUM_GLOBAL"
    PROPFILE="${SYSTEMD_CONFPATH}/nut-driver@$1.service.d/nut-driver-enumerator-generated-checksum.conf"
    [ -s "${PROPFILE}" ] \
    && egrep "^[ ${TABCHAR}]*Environment='$PROP=" "${PROPFILE}" | sed -e "s,^Environment='$PROP=,," -e "s,'\$,," \
    || { echo "Did not find '${PROPFILE}' with a $PROP" >&2 ; return 1; }
}
systemd_findSavedDeviceName() {
    # Returns long service instance name which has DEVICE=="$1"
    # For empty "$1" returns a list of all recorded "SVC<TAB>DEVICE"
    if [ -z "$1" ]; then
        egrep -H "^[ ${TABCHAR}]*Environment='DEVICE=" \
            /etc/systemd/system/nut-driver@*.service.d/nut-driver-enumerator-generated-devicename.conf \
        | sed 's|^/etc/systemd/system/\(nut-driver@[^/]*\.service\)\.d/.*DEVICE='"[\"']*\([^\"']*\)[\"']*"'$|\1\t\2|'
    else
        egrep -H "^[ ${TABCHAR}]*Environment='DEVICE=($1|\"$1\")'" \
            /etc/systemd/system/nut-driver@*.service.d/nut-driver-enumerator-generated-devicename.conf \
        | sed 's|^/etc/systemd/system/\(nut-driver@[^/]*\.service\)\.d/.*$|\1|'
    fi
}
systemd_getSavedDeviceName() {
    # Query service instance "$1" (quiet NO-OP if empty, for mis-use
    # in global sections context) to get the unquoted saved DEVICE
    # section name corresponding to this service instance
    [ -n "$1" ] || { echo ""; return 0; }
    PROP="DEVICE"
    PROPFILE="${SYSTEMD_CONFPATH}/nut-driver@$1.service.d/nut-driver-enumerator-generated-devicename.conf"
    [ -s "${PROPFILE}" ] \
    && egrep "^[ ${TABCHAR}]*Environment='$PROP=" "${PROPFILE}" | sed -e "s,^Environment='$PROP=,," -e "s,'\$,," -e 's,^"\(.*\)"$,\1,' \
    || { echo "Did not find '${PROPFILE}' with a $PROP" >&2 ; return 1; }
}
systemd_setSavedDeviceName() {
    # Save device (config section) name $2 into service instance $1
    [ -n "$1" ] || return # No-op for global section
    PROPFILE="${SYSTEMD_CONFPATH}/nut-driver@$1.service.d/nut-driver-enumerator-generated-devicename.conf"
    mkdir -p "${SYSTEMD_CONFPATH}/nut-driver@$1.service.d" && \
    cat > "${PROPFILE}" << EOF
[Service]
Environment='DEVICE="$2"'
EOF
    [ $? = 0 ] && echo "OK" || { echo "FAILED to stash the device name">&2 ; return 1 ; }
}
systemd_setSavedMD5() {
    # Save checksum value $2 into service instance $1
    PROP="SECTION_CHECKSUM"
    [ -n "$1" ] || PROP="SECTION_CHECKSUM_GLOBAL"
    PROPFILE="${SYSTEMD_CONFPATH}/nut-driver@$1.service.d/nut-driver-enumerator-generated-checksum.conf"
    mkdir -p "${SYSTEMD_CONFPATH}/nut-driver@$1.service.d" && \
    cat > "${PROPFILE}" << EOF
[Service]
Environment='$PROP=$2'
EOF
    [ $? = 0 ] && echo "OK" || { echo "FAILED to stash the checksum">&2 ; return 1 ; }
}
systemd_restart_upsd() {
    # Do not restart/reload if not already running
    case "`/bin/systemctl is-active "nut-server"`" in
        active|unknown) ;; # unknown meant "starting" in our testing...
        *) return 0 ;;
    esac

    echo "Restarting NUT data server to make sure it knows new configuration..."
    # Note: reload is a better way to go about this, so the
    # data service is not interrupted by re-initialization
    # of the daemon. But systemd/systemctl sometimes stalls...

    $TIMEOUT_CMD $TIMEOUT_ARGS /bin/systemctl reload-or-restart "nut-server" || \
    $TIMEOUT_CMD $TIMEOUT_ARGS /bin/systemctl restart "nut-server"
}

systemd_restart_drv() {
    # Do not restart/reload if not already running
    case "`/bin/systemctl is-active "nut-driver@$1"`" in
        active|unknown) ;;
        *) return 0 ;;
    esac

    echo "Restarting NUT driver instance '$1' to make sure it knows new configuration..."

    # Full restart, e.g. in case we changed the user= in configs
    $TIMEOUT_CMD $TIMEOUT_ARGS /bin/systemctl restart "nut-driver@$1"
}

upslist_normalizeFile_filter() {
    # See upslist_normalizeFile() detailed comments below; this routine
    # is a pipe worker to prepare the text into a simpler expected form.

    # Pick the lines which contain a bracket or assignment character,
    # or a single token (certain keywords come as just NUT "flags"),
    # trim leading and trailing whitespace, comment-only lines, and in
    # assignment lines trim the spaces around equality character and
    # quoting characters around assignment of values without whitespaces.
    # Any whitespace characters around a section name (single token that
    # starts the line and is enclosed in brackets) and a trailing comment
    # are dropped. Note that brackets with spaces inside, and brackets
    # that do not start the non-whitespace payload of the line, are not
    # sections.
    egrep -v '(^$|^#)' | \
    sed -e 's,^['"$TABCHAR"'\ ]*,,' \
        -e 's,^\#.*$,,' \
        -e 's,['"$TABCHAR"'\ ]*$,,' \
        -e 's,^\([^=\ '"$TABCHAR"']*\)['"$TABCHAR"'\ ]*=['"$TABCHAR"'\ ]*,\1=,g' \
        -e 's,=\"\([^\ '"$TABCHAR"']*\)\"$,=\1,' \
        -e 's,^\(\[[^]'"$TABCHAR"'\ ]*\]\)['"$TABCHAR"'\ ]*\(#.*\)*$,\1,' \
    | egrep -v '^$' \
    | egrep '([\[\=]|^[^ '"$TABCHAR"']*$|^[^ '"$TABCHAR"']*[ '"$TABCHAR"']*\#.*$)'
}

upslist_normalizeFile() {
    # Read the ups.conf file and find all defined sections (names of
    # configuration blocks for drivers that connect to a certain device
    # using specified protocol and media); normalize section contents
    # as detailed below, to simplify subsequent parsing and comparison.

    # File contents
    UPSCONF_DATA=""
    UPSCONF_DATA_SDP=""
    if [ -n "$UPSCONF" ] && [ -f "$UPSCONF" ] && [ -r "$UPSCONF" ]; then
        [ ! -s "$UPSCONF" ] \
        && echo "WARNING: The '$UPSCONF' file exists but is empty" >&2 \
        && return 0
        # Ok to continue - we may end up removing all instances
    else
        echo "FATAL: The '$UPSCONF' file does not exist or is not readable" >&2
        return 2
    fi

    # Store a normalized version of NUT configuration file contents.
    # Also use a SDP subset with just section, driver and port info
    # for faster parsing when determining driver-required media etc.
    UPSCONF_DATA="$(upslist_normalizeFile_filter < "$UPSCONF")" \
        && [ "${#UPSCONF_DATA}" != 0 ] \
        && UPSCONF_DATA_SDP="`egrep '^(\[.*\]|driver=|port=)' << EOF
$UPSCONF_DATA
EOF`" \
        ||  { echo "Error reading the '$UPSCONF' file or it does not declare any device configurations: nothing left after normalization" >&2
              UPSCONF_DATA=""
              UPSCONF_DATA_SDP=""
            }
}

upslist_normalizeFile_once() {
    # Wrapper that ensures that the parsing is only done once
    # (will re-parse if there were no devices listed on the
    # first time, though)
    [ "${#UPSCONF_DATA}" = 0 ] && [ "${#UPSCONF_DATA_SDP}" = 0 ] || return 0
    upslist_normalizeFile
}

upslist_readFile() {
    # Use the routine above (unconditionally) to get or update the
    # listing of device sections known at this moment.

    # List of devices from the config file
    UPSLIST_FILE=""
    if [ "$DO_NORMALIZE_ONCE" = yes ]; then
        upslist_normalizeFile_once || return    # Propagate errors upwards
    else
        upslist_normalizeFile || return    # Propagate errors upwards
    fi

    if [ "${#UPSCONF_DATA}" != 0 ] ; then
        # Note that section-name brackets should contain a single token
        UPSLIST_FILE="$(echo "$UPSCONF_DATA_SDP" | egrep '^\[[^'"$TABCHAR"'\ ]*\]$' | sed 's,^\[\(.*\)\]$,\1,' | sort -n)" \
            || UPSLIST_FILE=""
        if [ "${#UPSLIST_FILE}" = 0 ] ; then
            echo "Error reading the '$UPSCONF' file or it does not declare any device configurations: no section declarations in parsed normalized contents" >&2
        else
            update_validInstanceNames ${UPSLIST_FILE}
        fi
    fi
    # Ok to continue with empty results - we may end up removing all instances
}

upslist_readFile_once() {
    # Wrapper that ensures that the parsing is only done once
    # (will re-parse if there were no devices listed on the
    # first time, though)
    [ "${#UPSLIST_FILE}" = 0 ] || return 0
    DO_NORMALIZE_ONCE=yes upslist_readFile
}

upslist_readSvcs() {
    UPSLIST_SVCS="`$hook_listInstances`" || UPSLIST_SVCS=""
    if [ "${#UPSLIST_SVCS}" = 0 ] && [ "$1" != "-" ] ; then
        [ -z "$1" ] && EXPLAIN="" || EXPLAIN=" - $1"
        echo "Error reading the list of ${SERVICE_FRAMEWORK-} service instances for UPS drivers, or none are defined${EXPLAIN}" >&2
        # Ok to continue - we may end up defining new instances
    fi
}

upslist_readSvcs_once() {
    [ "${#UPSLIST_SVCS}" = 0 ] || return 0
    upslist_readSvcs
}

upslist_debug() {
    for UPSF in "" $UPSLIST_FILE ; do
        upsconf_debug "$UPSF"
    done
}

upslist_addSvcs() {
    # Note: This routine registers service instances for device config sections
    # that are not wrapped currently. Support for redefined previously existing
    # sections - is attained by removing the old service instance elsewhere and
    # recreating it here, since any data could change including the dependency
    # list, etc.
    for UPSF in $UPSLIST_FILE ; do
        if ! common_isRegistered "$UPSF" ; then
            echo "Adding new ${SERVICE_FRAMEWORK} service instance for power device [${UPSF}]..." >&2
            $hook_registerInstance "$UPSF"
        fi
    done
}

upslist_delSvcs() {
    for UPSS in $UPSLIST_SVCS ; do
        if ! common_isFiled "$UPSS" ; then
            echo "Dropping old ${SERVICE_FRAMEWORK} service instance for power device [${UPSS}] which is no longer in config file..." >&2
            $hook_unregisterInstance "$UPSS"
        fi
    done
}

upslist_restartSvcs() {
    for UPSS in $UPSLIST_SVCS ; do
        if common_isFiled "$UPSS" ; then
            $hook_restart_drv "$UPSS"
        fi
    done
}

# FIXME : process via kill -l?
# Different shells use a SIG prefix or not to signal names
# so standard numbers are in fact more portable :\
TERMINATION_SIGNALS="2 3 15"
RECONFIGURATION_SIGNALS="1"

TERMINATE_ASAP=false
trap_handle_interruption_exit() {
    # Handle SIGINT, SIGQUIT, SIGTERM with a message
    echo "`date -u` : Received an interruption signal, terminating the script now" >&2
    exit 0
}

trap_handle_interruption() {
    # Handle SIGINT, SIGQUIT, SIGTERM gracefully - tell the main
    # iteration to complete and just then abort
    echo "`date -u` : Received an interruption signal, will terminate the script after ending the main routine. Repeat the signal if urgent!" >&2
    TERMINATE_ASAP=true
    trap 'trap_handle_interruption_exit' $TERMINATION_SIGNALS
}

nut_driver_enumerator_main() {
    ################# MAIN PROGRAM by default
    TERMINATE_ASAP=false
    trap 'trap_handle_interruption' $TERMINATION_SIGNALS

    # Note: do not use the read..._once() here, to ensure that the
    # looped daemon sees the whole picture, which can be new every time
    upslist_readFile || return $?
    #upslist_debug
    upslist_readSvcs "before manipulations"

    # Test if global config has changed since last run
    RESTART_ALL=no
    upssvcconf_checksum_unchanged "" "" || { echo "`date -u` : Detected changes in global section of '$UPSCONF', will restart all drivers"; RESTART_ALL=yes; }

    # Quickly exit if there's nothing to do; note the lists are pre-sorted
    # Otherwise a non-zero exit will be done below
    # Note: We implement testing in detail whether section definitions were
    # changed since last run, as a first step before checking that name
    # lists are still equivalent, because we need to always have the result
    # of the "has it changed?" check as a hit-list of something to remove,
    # while the check for no new device section definitions is just boolean.
    # We can only exit quickly if both there are no changed sections and no
    # new or removed sections since last run.
    NEW_CHECKSUM="`upslist_checksums_unchanged "$UPSLIST_FILE" "$UPSLIST_SVCS"`" \
    && [ "${#NEW_CHECKSUM}" = 0 ] \
    && upslist_equals "$UPSLIST_FILE" "$UPSLIST_SVCS" \
    && if [ -z "$DAEMON_SLEEP" -o "${VERBOSE_LOOP}" = yes ] ; then \
        echo "`date -u` : OK: No changes to reconcile between ${SERVICE_FRAMEWORK} service instances and device configurations in '$UPSCONF'" ; \
       fi \
    && [ "$RESTART_ALL" = no ] && return 0

    if [ "${#NEW_CHECKSUM}" != 0 ]; then
        for UPSS in $NEW_CHECKSUM ; do
            echo "Dropping old ${SERVICE_FRAMEWORK} service instance ${UPSS} whose section in config file has changed..." >&2
            $hook_unregisterInstance "$UPSS"
        done
        upslist_readSvcs "after updating for new config section checksums"
    fi

    if [ "${#UPSLIST_SVCS}" != 0 ]; then
        # Drop services that are not in config file (any more?)
        upslist_delSvcs

        if [ "$RESTART_ALL" = yes ] && [ "$AUTO_START" = yes ] ; then
            # Here restart only existing services; new ones will (try to)
            # start soon after creation and upsd is handled below
            upslist_restartSvcs
        fi
    fi

    if [ "$RESTART_ALL" = yes ] ; then
        # Save new checksum of global config
        $hook_setSavedMD5 "" "`upsconf_getSection_MD5 ""`"
    fi

    if [ "${#UPSLIST_FILE}" != 0 ]; then
        # Add services for sections that are in config file but not yet wrapped
        upslist_addSvcs
        $hook_refreshSupervizor
        upslist_readSvcs "after checking for new config sections to define service instances"
    else
        # Require upslist_readSvcs_once() below to re-read current services
        UPSLIST_SVCS=""
    fi

    upslist_readSvcs_once
    if [ "${#UPSLIST_SVCS}" != 0 ] ; then
        echo "=== The currently defined service instances are:"
        echo "$UPSLIST_SVCS"
    fi

    if [ "${#UPSLIST_FILE}" != 0 ] ; then
        echo "=== The currently defined configurations in '$UPSCONF' are:"
        echo "$UPSLIST_FILE"
    fi

    # We had some changes to the config file; upsd must be made aware
    if [ "$AUTO_START" = yes ] ; then
        $hook_restart_upsd
    fi

    # Return 42 if there was a change applied succesfully
    # (but e.g. some services should restart - upsd, maybe upsmon)
    UPSLIST_EQ_RES=0
    upslist_equals "$UPSLIST_FILE" "$UPSLIST_SVCS" || UPSLIST_EQ_RES=$?

    # File processing and service startups take a while;
    # make sure upsconf did not change while we worked...
    # NOTE: Check this at the last moment to minimize
    # the chance of still not noticing the change made
    # at just the wrong moment.
    UPSCONF_CHECKSUM_END="`calc_md5_file "$UPSCONF"`" || true
    if [ "$UPSCONF_CHECKSUM_END" != "$UPSCONF_CHECKSUM_START" ] ; then
        # NOTE: even if daemonized, the sleep between iterations
        # can be configured into an uncomfortably long lag, so
        # we should re-sync the system config in any case.
        echo "`date -u` : '$UPSCONF' changed while $0 $* was processing its older contents; re-running the script to pick up the late-coming changes"
        # Make sure the cycle does not repeat itself due to diffs
        # from an ages-old state of the file from when we started.
        UPSCONF_CHECKSUM_START="$UPSCONF_CHECKSUM_END"
        ( nut_driver_enumerator_main ) ; return $?
        # The "main" routine at the end of recursions will
        # do REPORT_RESTART_42 logic or the error exit-code
    fi

    if [ "$UPSLIST_EQ_RES" = 0 ] ; then
        echo "`date -u` : OK: No more changes to reconcile between ${SERVICE_FRAMEWORK} service instances and device configurations in '$UPSCONF'"
        [ "${REPORT_RESTART_42-}" = no ] && return 0 || return 42
    fi
    return 13
}

nut_driver_enumerator_full_reconfigure() {
    # Similar to the main routine for reconciling data,
    # but this one removes all service instances and
    # defines current mappings from scratch after that
    upslist_readFile_once || return $?
    upslist_readSvcs "before manipulations"

    if [ "${#UPSLIST_SVCS}" != 0 ]; then
        for UPSS in $UPSLIST_SVCS ; do
            echo "Dropping old ${SERVICE_FRAMEWORK} service instance for power device [${UPSS}] to reconfigure the service unit..." >&2
            $hook_unregisterInstance "$UPSS"
        done
        upslist_readSvcs "after dropping"
    fi
    if [ "${#UPSLIST_FILE}" != 0 ]; then
        upslist_addSvcs
        upslist_readSvcs "after checking for new config sections to define service instances"
    fi

    # Save new checksum of global config
    $hook_setSavedMD5 "" "`upsconf_getSection_MD5 ""`"

    # Service units were manipulated, including saving of checksums;
    # refresh the service management daemon if needed
    $hook_refreshSupervizor

    if [ "${#UPSLIST_SVCS}" != 0 ] ; then
        echo "=== The currently defined service instances are:"
        echo "$UPSLIST_SVCS"
    fi

    if [ "${#UPSLIST_FILE}" != 0 ] ; then
        echo "=== The currently defined configurations in '$UPSCONF' are:"
        echo "$UPSLIST_FILE"
    fi

    # We had some changes to the config file; upsd must be made aware
    if [ "$AUTO_START" = yes ] ; then
        $hook_restart_upsd
    fi

    # Return 42 if there was a change applied succesfully
    # (but e.g. some services should restart - upsd, maybe upsmon)
    UPSLIST_EQ_RES=0
    upslist_equals "$UPSLIST_FILE" "$UPSLIST_SVCS" || UPSLIST_EQ_RES=$?

    # File processing and service startups take a while;
    # make sure upsconf did not change while we worked...
    # NOTE: Check this at the last moment to minimize
    # the chance of still not noticing the change made
    # at just the wrong moment.
    UPSCONF_CHECKSUM_END="`calc_md5_file "$UPSCONF"`" || true
    if [ "$UPSCONF_CHECKSUM_END" != "$UPSCONF_CHECKSUM_START" ] ; then
        echo "`date -u` : '$UPSCONF' changed while $0 $* was processing its older contents; re-running the script to pick up and reconcile the late-coming changes"
        nut_driver_enumerator_main ; return $?
        # The "main" routine will do REPORT_RESTART_42 logic too
    fi

    if [ "$UPSLIST_EQ_RES" = 0 ] ; then
        echo "`date -u` : OK: No more changes to reconcile between ${SERVICE_FRAMEWORK} service instances and device configurations in '$UPSCONF'"
        [ "${REPORT_RESTART_42-}" = no ] && return 0 || return 42
    fi

    return 13
}

list_services_for_devices() {
    # This routine actually processes the NUT configuration and the
    # service instances defined in the current operating environment
    # to compare the two lists and return the mapping of one to other
    FINAL_RES=0
    upslist_readFile_once && [ "${#UPSLIST_FILE}" != 0 ] \
        || { echo "No devices detected in '$UPSCONF'" >&2 ; return 1 ; }
    upslist_readSvcs "by user request" && [ "${#UPSLIST_SVCS}" != 0 ] \
        || { echo "No service instances detected" >&2 ; return 1; }
    UPSLIST_SVCS_RAW="`$hook_listInstances_raw`" && [ "${#UPSLIST_SVCS_RAW}" != 0 ] \
        || { echo "No service units detected" >&2 ; return 1; }
    for DEV in $UPSLIST_FILE ; do
        # First pass over simple verbatim names
        vUNITD="`$hook_validFullUnitName "$DEV"`"
        for INST in $UPSLIST_SVCS ; do
            # PERF: Find a way to reduce the iteration scope (to not repeat
            # passing items matched and processed already), here and below
            if [ "$INST" = "$DEV" ] ; then
                for UNIT in $UPSLIST_SVCS_RAW ; do
                    if [ "$UNIT" = "$vUNITD" ] ; then
                        printf '%s\t%s\n' "$UNIT" "$DEV"
                        continue 3
                    fi
                done
            fi
        done
        # Second pass over names that are not "service==device"
        vINST="`$hook_validInstanceName "$DEV"`"
        vUNITI="`$hook_validFullUnitName "$vINST"`"
        for INST in $UPSLIST_SVCS ; do
            if [ "$INST" = "$vINST" ] ; then
                for UNIT in $UPSLIST_SVCS_RAW ; do
                    if [ "$UNIT" = "$vUNITI" ] ; then
                        printf '%s\t%s\n' "$UNIT" "$DEV"
                        continue 3
                    fi
                done
            fi
        done
        echo "WARNING: no service instances detected that match device '$DEV'" >&2
        FINAL_RES=1
    done
    return $FINAL_RES
}

SVCS_DEVS_LIST=""
list_services_for_devices_once() {
    # On first call, caches the system reponse
    # On next calls returns what it got earlier
    # Does not return any text, just the exit code
    # (0 = data avail, even if empty, in SVCS_DEVS_LIST)
    [ "${#SVCS_DEVS_LIST}" != 0 ] && return

    # Pre-cache config file data, if nobody read it yet,
    # and keep in main script context for reuse (no subshell)
    upslist_readFile_once && \
    SVCS_DEVS_LIST="`list_services_for_devices "$@"`" || return $?
}

get_device_for_service() {
    [ -z "$1" ] && echo "Service (instance) name argument required" >&2 && return 1

    # Instance name can be a hash or "native" NUT section name
    SVC="`$hook_validInstanceSuffixName "$1"`" && [ -n "$SVC" ] \
    || { echo "Error getting SVC name from the inputs" >&2 ; return 1; }

    # Reading the config is too expensive to do for every
    # driver management attempt when there are many devices
    if [ "${USE_SAVEDINST-}" != false ]; then
        # Try to use last-stashed values from service properties first
        # (NOTE: saved value is assumed to be valid if present)
        SAVEDINST="`$hook_getSavedDeviceName "$SVC"`" || SAVEDINST=""
        [ "${#SAVEDINST}" = 0 ] || { echo "$SAVEDINST" ; return 0 ; }
    fi

    case "$SVC" in
        MD5_*) ;; # fall through to the bulk of code
        *)  upslist_readFile_once || return $?
            echo "${UPSLIST_FILE}" | egrep "^${SVC}\$"
            return $?
            ;;
    esac

    # Inspect SVC=MD5_* usecase
    FINAL_RES=0
    list_services_for_devices_once && [ "${#SVCS_DEVS_LIST}" != 0 ] || FINAL_RES=$?
    if [ "$FINAL_RES" = 0 ]; then
        echo "$SVCS_DEVS_LIST" | grep "$SVC" | ( \
            while read _SVC _DEV ; do
                _SVC="`$hook_validInstanceSuffixName "${_SVC}"`" || exit
                [ "${_SVC}" = "${SVC}" ] && echo "${_DEV}" && exit 0
            done ; exit 1 ) && return 0
    fi
    echo "No service instance '$1' was detected that matches a NUT device" >&2
    return 1
}

get_service_for_device() {
    DEV="$1"
    [ -z "$DEV" ] && echo "Device name argument required" >&2 && return 1

    # Cheap check in service instance metadata, if saved
    # (NOTE: saved value is assumed to be valid if present)
    if [ "${USE_SAVEDSVC-}" != false ]; then
        SAVEDSVC="`$hook_findSavedDeviceName "$DEV"`" || SAVEDSVC=""
        [ "${#SAVEDSVC}" = 0 ] || { echo "$SAVEDSVC" ; return 0 ; }
    fi

    # Trawl all the data we have...
    # TODO: Reorder to avoid extra parsing if we have an early hit?
    upslist_readSvcs "by user request" && [ "${#UPSLIST_SVCS}" != 0 ] \
        || { echo "No service instances detected" >&2 ; return 1; }
    UPSLIST_SVCS_RAW="`$hook_listInstances_raw`" && [ "${#UPSLIST_SVCS_RAW}" != 0 ] \
        || { echo "No service units detected" >&2 ; return 1; }
    vUNITD="`$hook_validFullUnitName "$DEV"`"

    # First pass over simple verbatim names
    for INST in $UPSLIST_SVCS ; do
        if [ "$INST" = "$DEV" ] ; then
            for UNIT in $UPSLIST_SVCS_RAW ; do
                if [ "$UNIT" = "$vUNITD" ] ; then
                    echo "$UNIT"
                    return 0
                fi
            done
        fi
    done
    # Second pass over other options
    vINST="`$hook_validInstanceName "$DEV"`"
    vUNITI="`$hook_validFullUnitName "$vINST"`"
    for INST in $UPSLIST_SVCS ; do
        if [ "$INST" = "$vINST" ] ; then
            for UNIT in $UPSLIST_SVCS_RAW ; do
                if [ "$UNIT" = "$vUNITI" ] ; then
                    echo "$UNIT"
                    return 0
                fi
            done
        fi
    done
    echo "No service instances detected that match device '$DEV'" >&2
    return 1
}

update_upslist_savednames_found_missing() {
    # Runs once in production modes that inspect and reconcile
    # configs, to handle upgraded NUT deployments
    SVCINSTS_NO_DEVICE="`upslist_savednames_find_missing`" || \
    case "$?" in
        1) return 0 ;; # No services defined yet
        2) ;; # All service units do not have DEVICE values
    esac
    # Something found... or not? Or all is populated?
    [ "${#SVCINSTS_NO_DEVICE}" != 0 ] || return 0

    # Make a list of what devices are known in config matched
    # to service instances defined in the system, if any
    # Note to not check the service instance properties which
    # we are validating and currently to not quite trust.
    USE_SAVEDINST=false list_services_for_devices_once \
    && [ "${#SVCS_DEVS_LIST}" != 0 ] || return 0

    # Go over services with no device value saved into properties,
    # and write the values learned from mapping above
    _MISSING_RES=0
    for SVCINST in $SVCINSTS_NO_DEVICE ; do
        _DEV="`printf '%s\n' "$SVCS_DEVS_LIST" | awk '( \$1 == "'"${SVCINST}"'" ) {print \$NF}'`"
        echo "Service instance '$SVCINST' did not have a device recorded into properties, setting to '${_DEV}'"
        [ -n "${_DEV}" ] || { echo "The device name value for '$SVCINST' is empty, skipping" >&2 ; _MISSING_RES=1 ; continue ; }
        $hook_setSavedDeviceName "`$hook_validInstanceSuffixName "$SVCINST"`" "${_DEV}" || _MISSING_RES=$?
    done
    return ${_MISSING_RES}
}

RECONFIGURE_ASAP=false
trap_handle_hup_main() {
    if [ "$TERMINATE_ASAP" = true ]; then
        echo "`date -u` : Received a HUP following an interruption signal, terminating the script now" >&2
        exit 0
    fi

    echo "`date -u` : Received a HUP during processing, scheduling reconfiguration to repeat ASAP (after the current iteration is done)" >&2
    # Note: in the worst case the reconfig would run twice;
    # we do not update UPSCONF_CHECKSUM_START in this case
    # to avoid corrupting decisions of the currently running
    # processing.
    RECONFIGURE_ASAP=true
}

trap_handle_hup_sleep() {
    echo "`date -u` : Received a HUP in my sleep, reprocessing configs right now!" >&2
    # Avoid re-parsing main twice, though don't recalculate
    # checksums needlessly on every loop cycle, either...
    UPSCONF_CHECKSUM_START="`calc_md5_file "$UPSCONF"`" || true
    RECONFIGURE_ASAP=true
    if [ -n "$1" ] ; then
        # Kill the sleeper PID
        kill "$1"
    fi
}

daemonize() {
    # Note: do not further sub-shell this routine, so systemd
    # is not confused whom to signal.
    echo "`date -u` : Daemonizing $0 with config re-evaluation frequency $DAEMON_SLEEP" >&2

    # Support (SIG)HUP == signal code 1 to quickly reconfigure,
    # e.g. to request it while the sleep is happening or while
    # "main" is processing an earlier change of the file.
    RECONFIGURE_ASAP=false
    trap 'trap_handle_hup_main' $RECONFIGURATION_SIGNALS

    update_upslist_savednames_found_missing

    # Note: this loop would die on errors with config file or
    # inability to ensure that it matches the list of services.
    # If caller did not `export REPORT_RESTART_42=no` then the
    # loop would exit with code 42, and probably trigger restart
    # of the service which wraps this daemon do topple others that
    # depend on it.
    # Note: do not quickly skip the "main" based on full-file
    # checksum refresh, to ensure that whatever is configured
    # gets applied (e.g. if user disabled some services or they
    # died, or some config was not applied due to coding error).
    while nut_driver_enumerator_main ; do
        trap 'trap_handle_interruption_exit' $TERMINATION_SIGNALS
        if $TERMINATE_ASAP ; then
            echo "`date -u` : Trapped a SIGTERM/SIGINT/SIGQUIT during last run of nut_driver_enumerator_main, terminating gracefully now" >&2
            exit 0
        fi

        if $RECONFIGURE_ASAP ; then
            echo "`date -u` : Trapped a SIGHUP during last run of nut_driver_enumerator_main, repeating reconfiguration quickly" >&2
        else
            sleep $DAEMON_SLEEP &
            trap "trap_handle_hup_sleep $!" $RECONFIGURATION_SIGNALS
            wait $!
        fi
        RECONFIGURE_ASAP=false
        trap 'trap_handle_hup_main' $RECONFIGURATION_SIGNALS
    done
    exit $?
}

# Save the checksum of ups.conf as early as possible,
# to test in the end that it is still the same file.
UPSCONF_CHECKSUM_START="`calc_md5_file "$UPSCONF"`" || true

# By default, update wrapping of devices into services
if [ $# = 0 ]; then
    update_upslist_savednames_found_missing
    nut_driver_enumerator_main ; exit $?
fi

if [ $# = 1 ] ; then
    [ -n "$DAEMON_SLEEP" ] || DAEMON_SLEEP=60
    # Note: Not all shells have 'case ... ;&' support
    case "$1" in
        --daemon=*) DAEMON_SLEEP="`echo "$1" | sed 's,^--daemon=,,'`" ;;
        --daemon-after=*) DAEMON_SLEEP="`echo "$1" | sed 's,^--daemon-after=,,'`" ;;
    esac
    case "$1" in
        --daemon-after|--daemon-after=*)
            REPORT_RESTART_42=no nut_driver_enumerator_main || exit $?
            daemonize &
            exit $?
            ;;
        --daemon|--daemon=*)
            daemonize &
            exit $?
            ;;
    esac
fi
unset DAEMON_SLEEP

usage() {
    cat << EOF
$0 (no args)
        Update wrapping of devices into services
$0 --daemon(=freq)
        Update wrapping of devices into services in an infinite loop
        Default freq is 60 sec
$0 --daemon-after(=freq)
        Update wrapping of devices into services in an infinite loop;
        first do one run of the loop though, then daemonize (this way
        service unit is deemed started only when NUT config and driver
        instances are in sync). Default freq is 60 sec.
$0 --reconfigure
        Stop and un-register all service instances and recreate them
        (e.g. if new dependency template was defined in a new
        version of this script and/or NUT package)
$0 --get-service-framework
        Print the detected service
        management framework in this OS
$0 --list-devices
        Print list of devices in NUT config
$0 --list-services
        Print list of service instances which wrap registered
        NUT devices (full name of service unit)
$0 --list-instances
        Print list of service instances which wrap registered
        NUT devices (just instance suffix)
$0 --get-service-for-device DEV
        Print the full name of service unit which wraps a NUT
        device named "DEV"
$0 --get-device-for-service SVC
        Print the NUT device name for full or instance-suffix name of
        a service unit which wraps it
$0 --list-services-for-devices
        Print a TAB-separated list of service units and corresponding
        NUT device names which each such unit wraps
$0 --show-configs|--show-all-configs
        Show the complete normalized list of device configuration blocks
$0 --show-config DEV
$0 --show-device-config DEV
        Show configuration block of the specified NUT device
$0 --show-device-config-value DEV KEY [KEY...]
        Show single configuration key value of the specified NUT device
        For flags, shows the flag name if present in the section
        If several keys or flags are requested, their values are reported
        one per line in the same order (including empty lines for missing
        values); any missing value yields a non-zero exit code.
EOF
}

while [ $# -gt 0 ]; do
    case "$1" in
        --help|-h|-help) usage; exit 0 ;;
        --get-service-framework) echo "${SERVICE_FRAMEWORK}" ; exit 0 ;;
        --reconfigure)
            nut_driver_enumerator_full_reconfigure "$@"
            exit $?
            ;;
        --list-devices)
            upslist_readFile_once && \
            if [ "${#UPSLIST_FILE}" != 0 ] ; then
                echo "=== The currently defined configurations in '$UPSCONF' are:" >&2
                echo "$UPSLIST_FILE"
                exit 0
            fi
            echo "No devices detected in '$UPSCONF'" >&2
            exit 1
            ;;
        --list-services)
            UPSLIST_SVCS_RAW="`$hook_listInstances_raw`" && \
            if [ "${#UPSLIST_SVCS_RAW}" != 0 ] ; then
                echo "=== The currently defined service units are:" >&2
                echo "$UPSLIST_SVCS_RAW"
                exit 0
            fi
            echo "No service units detected" >&2
            exit 1
            ;;
        --list-instances)
            upslist_readSvcs "by user request" && \
            if [ "${#UPSLIST_SVCS}" != 0 ] ; then
                echo "=== The currently defined service instances are:" >&2
                echo "$UPSLIST_SVCS"
                exit 0
            fi
            echo "No service instances detected" >&2
            exit 1
            ;;
        --get-service-for-device)
            shift
            get_service_for_device "$@"
            exit $?
            ;;
        --get-device-for-service)
            shift
            get_device_for_service "$@"
            exit $?
            ;;
        --list-services-for-devices)
            shift
            list_services_for_devices "$@"
            exit $?
            ;;
        --show-configs|--show-device-configs|--show-all-configs|--show-all-device-configs)
            RES=0
            upslist_readFile_once || RES=$?
            [ "$RES" != 0 ] && { echo "ERROR: upslist_readFile_once () failed with code $RES" >&2; exit $RES; }
            [ "${#UPSLIST_FILE}" != 0 ] \
                || { echo "WARNING: No devices detected in '$UPSCONF'" >&2 ; RES=1 ; }
            echo "$UPSCONF_DATA"
            exit $RES
            ;;
        --show-config|--show-device-config)
            [ -z "$2" ] && echo "WARNING: Device name argument empty, will show global config" >&2
            DEV="$2"
            upsconf_getSection "$DEV"
            exit $?
            ;;
        --show-config-value|--show-device-config-value)
            [ -z "$3" ] && echo "At least one configuration key name argument is required" >&2 && exit 1
            [ -z "$2" ] && echo "WARNING: Device name argument empty, will show global config" >&2
            DEV="$2"
            shift 2
            upsconf_getValue "$DEV" "$@"
            exit $?
            ;;
        devel-debug) # Not public, not in usage()
            shift
            echo "DEVEL-DEBUG: Will execute routine (maybe with args): $*"
            [ "$#" = 0 ] && { echo "ERROR: Nothing to execute" >&2 ; exit 1 ; }
            [ "${NDE_DEVEL_DEBUG}" = true ] || { echo "ERROR: NDE_DEVEL_DEBUG is not allowed" >&2 ; exit 2; }
            # Actually a small script can be passed this way, it is intended
            ( eval "$@" ) ; exit $?
            ;;
        upsconf_debug) # Not public, not in usage()
            [ -z "$2" ] && echo "Device name argument required" >&2 && exit 1
            upsconf_debug "$2"
            exit $?
            ;;
        upslist_debug) # Not public, not in usage()
            upslist_readFile_once || exit
            upslist_debug
            exit $?
            ;;
        upslist_savednames_find_missing) # Not public, not in usage()
            upslist_savednames_find_missing
            exit $?
            ;;
        upslist_savednames_find_mismatch) # Not public, not in usage()
            upslist_savednames_find_mismatch
            exit $?
            ;;
        update_upslist_savednames_found_missing) # Not public, not in usage()
            update_upslist_savednames_found_missing
            exit $?
            ;;
        hook_findSavedDeviceName) shift ; $hook_findSavedDeviceName "$@" ; exit $? ;;
        hook_getSavedDeviceName) shift ; $hook_getSavedDeviceName "$@" ; exit $? ;;
        *) echo "Unrecognized argument: $1" >&2 ; exit 1 ;;
    esac
    shift
done
